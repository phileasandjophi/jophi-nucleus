<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jophi Universe | Living Undulation</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #010102; font-family: 'Inter', sans-serif; }
        #canvas-container { width: 100%; height: 100%; display: block; }
        #hud { position: absolute; top: 30px; left: 30px; z-index: 10; pointer-events: none; mix-blend-mode: screen; }
        .label { font-size: 10px; letter-spacing: 3px; color: #00f2ff; text-transform: uppercase; text-shadow: 0 0 10px rgba(0, 242, 255, 0.8); }
        .sub { font-size: 8px; color: rgba(255, 255, 255, 0.6); margin-top: 5px; letter-spacing: 1px; }
    </style>
</head>
<body>
    <div id="hud">
        <div class="label">B.L.U.E.E. PROTOCOL // SYSTEM: UNDULATING_AETHER</div>
        <div class="sub">Bi-directional Ledger for Universal Ecological Expansion</div>
    </div>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // 1. SCENE SETUP & DEEP FOG
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x010102, 0.0012); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.z = 400;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = getTexture();

        // 2. LAYER 1: DEEP AMBIENT VOID
        const ambientGeo = new THREE.BufferGeometry();
        const ambientPos = [];
        for (let i = 0; i < 2000; i++) {
            ambientPos.push((Math.random() - 0.5) * 2500, (Math.random() - 0.5) * 2500, (Math.random() - 0.5) * 2000);
        }
        ambientGeo.setAttribute('position', new THREE.Float32BufferAttribute(ambientPos, 3));
        const ambientMat = new THREE.PointsMaterial({ size: 1.5, color: 0x445577, map: particleTexture, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.3, depthWrite: false });
        const ambientVoid = new THREE.Points(ambientGeo, ambientMat);
        scene.add(ambientVoid);

        // 3. LAYER 2: SWARMING REEFS
        const swarms = [];
        const swarmPalettes = [
            [0x00f2ff, 0xffffff], [0xffaa00, 0xff4400], [0xaa00ff, 0x0066ff]
        ];

        for (let i = 0; i < 4; i++) { 
            const swarmGroup = new THREE.Group();
            swarmGroup.position.set((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800);
            swarmGroup.userData = {
                vx: (Math.random() - 0.5) * 1.2, vy: (Math.random() - 0.5) * 1.2, vz: (Math.random() - 0.5) * 2.0,
                rotSpeed: (Math.random() - 0.5) * 0.01
            };

            const nodesCount = 80;
            const nodesGeo = new THREE.BufferGeometry();
            const nodesPos = [];
            const nodesColor = [];
            const colors = swarmPalettes[i % swarmPalettes.length];

            for (let j = 0; j < nodesCount; j++) {
                const radius = Math.random() * 120;
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                nodesPos.push(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
                const c = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
                nodesColor.push(c.r, c.g, c.b);
            }
            nodesGeo.setAttribute('position', new THREE.Float32BufferAttribute(nodesPos, 3));
            nodesGeo.setAttribute('color', new THREE.Float32BufferAttribute(nodesColor, 3));
            
            const nodesMat = new THREE.PointsMaterial({ size: 5, vertexColors: true, map: particleTexture, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8, depthWrite: false });
            swarmGroup.add(new THREE.Points(nodesGeo, nodesMat));
            scene.add(swarmGroup);
            swarms.push(swarmGroup);
        }

        // 4. LAYER 3: THE UNDULATING JELLYFISH (Aether Rays)
        // We create parametric planes consisting of many vertices that we will animate
        const aethers = [];
        const aetherColors = [0x00f2ff, 0xaa00ff, 0xffaa00];
        
        for(let i = 0; i < 3; i++) {
            // A wide plane with many segments so it can ripple smoothly
            const aGeo = new THREE.PlaneGeometry(300, 300, 30, 30);
            
            // We use a wireframe/point material to make it look like a fibrous net/jellyfish
            const aMat = new THREE.PointsMaterial({
                color: aetherColors[i],
                size: 2,
                map: particleTexture,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.6,
                depthWrite: false
            });
            
            const aMesh = new THREE.Points(aGeo, aMat);
            
            // Random placement and rotation
            aMesh.position.set((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800, (Math.random() - 0.5) * 600);
            aMesh.rotation.x = Math.random() * Math.PI;
            aMesh.rotation.y = Math.random() * Math.PI;
            
            // Store original coordinates so the wave math doesn't degrade the shape
            aMesh.userData.originalPositions = new Float32Array(aGeo.attributes.position.array);
            aMesh.userData.waveSpeed = 1.5 + Math.random();
            aMesh.userData.waveFrequency = 0.02 + Math.random() * 0.02;
            aMesh.userData.driftSpeed = { x: (Math.random()-0.5), y: (Math.random()-0.5), z: (Math.random()-0.5)*2 };
            
            scene.add(aMesh);
            aethers.push(aMesh);
        }

        // 5. LAYER 4: FAST ANOMALIES
        const anomalyGeo = new THREE.BufferGeometry();
        const anomalyPos = [];
        const anomalyVelocities = [];
        for (let i = 0; i < 15; i++) {
            anomalyPos.push((Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 1000, (Math.random() - 0.5) * 800);
            anomalyVelocities.push({ x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2, z: 3 + Math.random() * 5 });
        }
        anomalyGeo.setAttribute('position', new THREE.Float32BufferAttribute(anomalyPos, 3));
        const anomalyMat = new THREE.PointsMaterial({ size: 50, color: 0xffffff, map: particleTexture, blending: THREE.AdditiveBlending, transparent: true, opacity: 1.0, depthWrite: false });
        const anomalies = new THREE.Points(anomalyGeo, anomalyMat);
        scene.add(anomalies);

        // 6. ANIMATION LOOP
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.1;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.1;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            camera.position.x += (mouseX - camera.position.x) * 0.05;
            camera.position.y += (-mouseY - camera.position.y) * 0.05;
            camera.lookAt(scene.position);

            ambientVoid.rotation.y = time * 0.01;

            swarms.forEach(swarm => {
                swarm.rotation.y += swarm.userData.rotSpeed;
                swarm.rotation.x += swarm.userData.rotSpeed * 0.5;
                swarm.position.x += swarm.userData.vx;
                swarm.position.y += swarm.userData.vy;
                swarm.position.z += swarm.userData.vz;

                if (swarm.position.x > 1000) swarm.position.x = -1000;
                if (swarm.position.x < -1000) swarm.position.x = 1000;
                if (swarm.position.y > 800) swarm.position.y = -800;
                if (swarm.position.y < -800) swarm.position.y = 800;
                if (swarm.position.z > 800) swarm.position.z = -1200;
                if (swarm.position.z < -1200) swarm.position.z = 800;
            });

            // THE JELLYFISH / RUG UNDULATION MATH
            aethers.forEach(aether => {
                const positions = aether.geometry.attributes.position.array;
                const originals = aether.userData.originalPositions;
                const freq = aether.userData.waveFrequency;
                const speed = aether.userData.waveSpeed;

                for (let i = 0; i < positions.length; i += 3) {
                    const x = originals[i];
                    const y = originals[i+1];
                    // Ripple the Z axis using Sine and Cosine waves based on X, Y, and Time
                    positions[i+2] = originals[i+2] + Math.sin(x * freq + time * speed) * Math.cos(y * freq + time * speed) * 30;
                }
                aether.geometry.attributes.position.needsUpdate = true;

                // Drift the entire undulating shape slowly through space
                aether.position.x += aether.userData.driftSpeed.x;
                aether.position.y += aether.userData.driftSpeed.y;
                aether.position.z += aether.userData.driftSpeed.z;

                // Rotate it gently like a creature looking around
                aether.rotation.z = Math.sin(time * 0.2) * 0.2;

                if (aether.position.z > 800) aether.position.z = -1200;
            });

            const aPos = anomalies.geometry.attributes.position.array;
            for (let i = 0; i < 15; i++) {
                aPos[i * 3] += anomalyVelocities[i].x;
                aPos[i * 3 + 1] += anomalyVelocities[i].y;
                aPos[i * 3 + 2] += anomalyVelocities[i].z;
                if (aPos[i * 3 + 2] > 600) { 
                    aPos[i * 3] = (Math.random() - 0.5) * 1000;
                    aPos[i * 3 + 1] = (Math.random() - 0.5) * 1000;
                    aPos[i * 3 + 2] = -1500; 
                }
            }
            anomalies.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window
